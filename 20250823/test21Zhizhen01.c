// 指针01
//  1. 指针是内存中一个最小单元(1byte)的编号，也就是地址
//  2. 平时口语中说的指针，通常指的是指针变量，是用来存放内存地址的变量
//  总结：指针就是地址，口语中说的指针通常指的是指针变量
int *test() // 返回整型指针
{
    int a = 10;
    return &a;
}
int my_strlen(char *str)
{
    char *start = str; // 复制指针的值，让 start 和 str 指向同一个字符序列。
    while (*str != '\0')
        str++;
    return str - start;
}
#define N_VALUES 5
#include <stdio.h>
int main()
{
    int a = 10;  // 在内存中开辟一块空间
    int *p = &a; // 这里我们对变量a，取出它的地址，可以使用&操作符。
    // a变量占用4个字节的空间，这里是将a的4个字节的第一个字节的地址存放在p变量中，p就是一个指针变量。
    // 指针的大小在32位(x86)平台是4个字节，在64位(x64)平台是8个字节
    // int* 类型的指针是为了存放 int 类型变量的地址
    // sizeof 返回的值的类型是无符号整型 unsigned int
    int n = 0x11223344;
    int *pi = &n;
    char *pc = (char *)&n; // 强制转换

    // *pc = 0;
    // *pi = 0;
    // char* 的指针解引用就只能访问一个字节，而 int* 的指针的解引用就能访问四个字节。
    // 换言之，指针类型决定了指针在被解引用的时候访问几个字节
    printf("n地址为%p\n", &n);
    printf("pi=%p\n", pi);
    printf("pi+1=%p\n", pi + 1); // 指向int,+1变4个字节
    printf("pc=%p\n", pc);       // 和pi一致
    printf("pc+1=%p\n", pc + 1); // 指向char,+1变1个字节
    // 指针的类型决定了指针向前或者向后走一步有多大（距离）

    // 野指针:野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）
    // case1:指针未初始化
    // int *p1;  // 局部变量指针未初始化，意味着没有明确的方向，默认为随机值
    // *p1 = 20; // 非法访问内存了，p1是野指针
    // // case2:指针越界访问
    // int arr[10] = {0};
    // int *p2 = arr; //&arr[0]
    // int i = 0;
    // for (i = 0; i <= 11; i++)
    //     *(p++) = i; // 当指针指向的范围超出数组arr的范围时，p就是野指针
    // // case3:指针指向的空间释放
    // int *p3 = test(); // 实际指向是a，但是a在函数结束后的开辟内存空间已经销毁，故非法访问(虽然非法，但依然能访问到)

    // 如何规避野指针
    //  1. 指针初始化(初始化不确定指向就用NULL代替，「NULL->0」)
    //  2. 小心指针越界
    //  3. 指针指向空间释放及时置NULL
    //  4. 避免返回局部变量的地址
    //  5. 指针使用之前检查有效性

    // 指针运算
    //  1.指针+- 整数
    float values[N_VALUES];
    float *vp;
    // 指针+-整数；指针的关系运算
    for (vp = &values[0]; vp < &values[N_VALUES];)
    {
        *vp++ = 0;
    }
    //*vp++ 是 *vp和vp++ 让vp向右移之后 解引用vp指向变量(后缀++优先级高于*)
    //(*vp)++ 先对vp解引用，对*vp指向值再++

    // 2.指针-指针（得到的绝对值是指针与指针之间元素的个数）[无论char还是int还是。。。]
    // 不是所有指针都能相减，指向同一快空间的2个指针才能相减(但是指针相加没有任何意义)
    // eg:&arr[0]-&arr[9]
    int len = my_strlen("abvcedf"); // 字符串视为数组，传回的是a的地址
    printf("%d\n", len);
    // 3.指针的关系运算
    // eg *--vp 先让vp左移然后再解引用
    // 标准规定：允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。
    // 可以vp < &values[N_VALUES]; 但不能vp >values[-1]这样

    // 数组与指针
    int arr[10] = {0};
    printf("%p\n", arr);            //(1)arr就是数组首元素地址
    printf("%p\n", arr + 1);        //+1后移一位多4个字节
    printf("*arr    = %d\n", *arr); // 第一个元素的值

    printf("%p\n", &arr[0]);     //(2)数组首元素地址
    printf("%p\n", &arr[0] + 1); //+1后移1位多4个字节

    printf("%p\n", &arr);     //(3)数组地址
    printf("%p\n", &arr + 1); // 整个数组都挪，多40个字(sz=10)
    // 看似（1）和（3）一样但是后续意义不同(+1后（1)多4字节（3）多40字节
    // 仅在&+数组名【case(3)】 or sizeof(数组名)时数组才是数组本身，其他时候数组名都能当作数组首元素地址
    // 只要是arr的就是指针变量(首元素地址),输出字符串时arr也是指针变量[Note:地址是一个常量值]

    // 二级指针:指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪里？存在二级指针 。
    int a1 = 10;
    int *pa = &a1;   // pa是一个指针变量,一级指针变量
    int **ppa = &pa; // pa是一个二级指针变量（int* (* ppa))* ppa:说明ppa是指针变量，int*说明ppa指向的类型是int * 变量
    **ppa = 20;      // 解引用2次才能访问a

    // 指针数组:是存放指针的数组,本质是数组
    int *arr3[5];
    // arr3是一个数组，有五个元素，每个元素是一个整形指针。
    // 指针数组应用（当成二维数组用）
    int arr01[4] = {1, 2, 3, 4};
    int arr02[4] = {2, 3, 4, 5};
    int arr03[4] = {3, 4, 5, 6};

    int *parr[3] = {arr01, arr02, arr03};
    int i = 0;
    for (i = 0; i < 3; i++)
    {
        int j = 0;
        for (j = 0; j < 4; j++)
        {
            printf("%d ", parr[i][j]);//第一个[]是确定parr的下标，第二个[]是确定各自数组的指针的位次
            //                                                         arr[i] <==> *(arr+i)
        }
        printf("\n");
    }
    return 0;
}
