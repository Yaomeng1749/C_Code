// 操作符详解
//  操作符分类：
//  1.算术操作符+ — * /(整型和浮点型) %(唯一仅整型)
//  2.移位操作符(移动的是二进制位【补码】)（移位操作符的操作数只能是整数且不要移动负数位）
//           <<左移[左边抛弃、右边补0]
//           >>右移[右移运算分两种：1. 逻辑移位[左边用0填充，右边丢弃]2. 算术移位[左边用原该值的符号位填充，右边丢弃]vscode默认算数移位
/*
整数的二进制制表示有3种
原码
反码
补码

正的整数的原码、反码、补码相同
负的整数的原码、反码、补码是要计算的

7(整型占位4字节，ie 32比特，所以二进制有32位)
00000000000000000000000000000111 - 原码
00000000000000000000000000000111 - 反码
00000000000000000000000000000111 - 补码

-7（符号位为第一位，=0时为正，=1时为负）
10000000000000000000000000000111 - 原码
11111111111111111111111111111000 - 反码（原码的符号位不变，其他位按位取反就是反码）
11111111111111111111111111111001 - 补码（反码+1就是补码）
整数在内存中存储的是补码
*/

// 3.位操作符(二进制) &按位与 ｜按位或 ^按位异或 【依旧要有补码 -> 反码 -> 原码的转换】

// 4.赋值操作符 =是才赋值 (==是判断相等) or 复合赋值操作符 += /= <<= &= 等

// 5.单目操作符(只有1个操作数) // 双目操作符a+b(2个操作数)
/*!           逻辑反操作
-           负值
+           正值
&           取地址
sizeof      操作数的类型长度（以字节为单位）
~           对一个数的二进制按位取反（对补码取反「符号位也取反」在补码 到 反码{符号位这里不取反} 再到 原码）
--          前置、后置--
++          前置、后置++
*           间接访问操作符(解引用操作符)「针对指针」
(类型)       强制类型转换：eg int a=(int) 3.14;
*/

// 6.关系操作符 eg == 特例:"abc"=="avdcef" 不是比长度而是比两字符串的首字符地址 ;比长度要用strcmp("abc","avdcef")

// 7.逻辑操作符:&&逻辑与 ,||逻辑或
// a&&b:a和b里只要有一个假（=0）结果就是假 ，a||b:a和b里只要有一个真（不等于0）结果就是真

// 8.条件操作符or三目操作符 a?b:c 若a真则表达b，若a假则表达c

// 9.逗号表达式 :从左向右依次执行 d=(c=a+2,a=b-c,c-3) 从左到右算完，最后一个式子的结果就是d的值
// 如果是逗号表达式是（3，4）那结果就是最后的表达式 （3，4）等价于 4

// 10.下标引用、函数调用和结构成员
// 下标引用: []arr[7]=7[arr]=*(arr+7)=arr+7
// 函数调用: ()
// 结构成员: . :结构体.成员名 ; -> :结构体指针->成员名 ps->age = (*ps).age
#include <stdio.h>
#include <string.h> //strcpy的库
struct Stu
{
    // 结构体的成员
    char name[20];
    int age;
    double score;
}; // 有分号
void set_stu(struct Stu *ps)
{
    // strcpy((*ps).name, "zhangsan");
    // (*ps).age = 20;
    // (*ps).score = 100.0;
    strcpy(ps->name, "zhangsan");
    ps->age = 20;
    ps->score = 100.0;
}

void print_stu(struct Stu ss)
{
    printf("%s %d %lf\n", ss.name, ss.age, ss.score);
}

int main()
{
    int a1 = -7;
    int b1 = a1 >> 1;
    printf("2.移位操作符实例\n");
    printf("a1=%d\n", a1); // a=[00000000000000000000000000000111]2=7
    printf("b1=%d\n", b1); // b=[00000000000000000000000000001110]2=14
    // 负数同理，但是变完要从补码变成原码然后再算（正数是因为都一致所以转不转结果都一样）
    printf("3.位操作符实例\n");
    int a = 3;
    int b = -5;
    int c = a & b;
    // 00000000000000000000000000000011  - 3 的补码
    // 10000000000000000000000000000101 (-5原码)
    // 11111111111111111111111111111010 (-5反码)
    // 11111111111111111111111111111011  - -5 的补码
    // 00000000000000000000000000000011  - 3 的补码
    // 00000000000000000000000000000011  - a&b
    // %d 意味着打印一个有符号的整数
    // 与&: 两边只要有1个0就是0，只有两边都是1才是1
    // 或｜: 两边只要有1个1就是1，只有两边都是0才是0
    // 异或^: 两边相同就是0，两边不同就是1
    // 异或支持交换律 a^b^c=a^c^b=d 且a^a=0,0^a=0
    printf("c=%d\n", c);

    // 面试题：不能创建临时变量（第三个变量），实现两个数的交换
    //  a=a+b;
    //  b=a-b;
    //  a=a-b;虽说可行，但是这个方法如果a+b溢出容量上限就不行了
    a = a ^ b; // [a^a=0,0^a=0](当成a1=a^b)
    b = a ^ b; // b=a1^b=a^b^b=a
    a = a ^ b; // a=a1^b=a^b^a=a^a^b=b
    // 这方法只适用于整型
    printf("面试题\n");
    printf("a = %d b = %d\n", a, b);

    a = 10;
    int x = a++; // 先把a值赋给x之后a再=a+1
    printf("5.单目操作符(只有1个操作数) \n");
    printf("a = %d \n", a);
    printf("x = %d \n", x);
    printf("a = %d \n", a--); // 先赋给%d再--
    printf("a = %d \n", a);

    printf("结合逻辑操作符和弹幕操作符的有趣案例\n");
    int i = 0, a2 = 0, b2 = 2, c2 = 3, d2 = 4;
    i = a2++ && ++b2 && d2++; // Note：因为a2是0假的,所以后面就都不算了直接出了，b2d2无变化,仅是真时才会继续走(哪里假了哪里之后停)
    // i = a++||++b||d++;仅是假时才会继续走(哪里真了哪里之后停)
    printf("a2 = %d\n b2 = %d\n c2 = %d\nd2 = %d\n", a2, b2, c2, d2);

    struct Stu s = {0};
    set_stu(&s);
    print_stu(s);
    // 有符号的根据二进制位最高位(符号位)决定补0还是补1

    // 负数的整形提升
    char c3 = -1; // -1是整数，32个比特位
                  // 10000000000000000000000000000001
                  // 11111111111111111111111111111110
                  // 11111111111111111111111111111111 -> -1的补码
                  // 11111111 - c(char类型变量c1的二进制位(补码)中只有8个比特位)【截断:对于提升至整型展开阶段前8位，后面都不要】
                  // 11111111111111111111111111111111 整型提升
    // 整形提升的时候，高位补充符号位，即为1

    // 正数的整形提升
    char c4 = 1;
    // 变量c2的二进制位(补码)中只有8个比特位： 00000001
    // 高位补充符号位，即为0
    // 提升之后的结果是：00000000000000000000000000000001
    // 无符号整形提升，高位补0

    printf("整型提升实例\n");
    char a0 = 5;
    // 00000000000000000000000000000101 先当整型展开
    // 00000101 - a 截断

    char b0 = 126;
    // 00000000000000000000000001111110 先当整型展开
    // 01111110 - b 截断

    char c0 = a0 + b0;
    // 00000000000000000000000000000101 - a 整型提升
    // 00000000000000000000000001111110 - b 整型提升
    // 00000000000000000000000010000011
    // 10000011 - c 截断(这步为必要环节，因为是char，不能直接跳步到下步)
    // 11111111111111111111111110000011 - 补码（因%d而整型提升)
    // 11111111111111111111111110000010
    // 10000000000000000000000001111101

    printf("%d\n", c0); // -125

    // 实例1

    char a5 = 0xb6;
    short b5 = 0xb600;
    int c5 = 0xb6000000;
    // a,b要进行整形提升,但是c不需要整形提升
    // a,b整形提升之后,变成了负数 a的展开第8为是1，b的展开第16位是1，整型展开就变成负数了(原本a,b是正的)
    if (a5 == 0xb6)
        printf("a\n");
    if (b5 == 0xb600)
        printf("b\n");
    if (c5 == 0xb6000000)
        printf("c\n");

    // 实例2
    char c00 = 1;
    printf("%zu\n", sizeof(c00));
    printf("%zu\n", sizeof(+c00));
    printf("%zu\n", sizeof(-c00));
    //c只要参与表达式运算,就会发生整形提升,表达式 +c ,就会发生提升,所以 sizeof(+c) 是4个字节

    //操作符优先级
    //eg:answer = fun() - fun() * fun(); 中我们只能通过操作符的优先级得知：先算乘法，再算减法。
    //函数的调用先后顺序无法通过操作符的优先级确定。
    return 0;
}

//总结：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的。
